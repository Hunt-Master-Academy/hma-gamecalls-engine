#!/usr/bin/env bash
set -euo pipefail

# Huntmaster Engine – Coverage measurement (CMake/Ninja + gcovr)
# This script assumes the coverage preset/config is already generated by the caller.
# If not, it will attempt to configure and build using the docker-coverage preset.

echo "=== Huntmaster Engine Coverage Analysis ==="

PROJECT_ROOT=$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)
BUILD_DIR_REL=${BUILD_DIR:-build/coverage}
BUILD_DIR="$PROJECT_ROOT/$BUILD_DIR_REL"
TEST_BIN="$BUILD_DIR/tests/RunEngineTests"
OUT_DIR="$PROJECT_ROOT/coverage_reports"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
XML_OUT="$OUT_DIR/coverage_${TIMESTAMP}.xml"
HTML_DIR="$OUT_DIR/html_${TIMESTAMP}"
TXT_LOG="$OUT_DIR/coverage_${TIMESTAMP}.log"
COVERAGE_TARGET=${COVERAGE_TARGET:-90}
ENFORCE_COVERAGE=${ENFORCE_COVERAGE:-false}

mkdir -p "$OUT_DIR"

echo "Project root: $PROJECT_ROOT"
echo "Build dir:    $BUILD_DIR"
echo "Output dir:   $OUT_DIR"

# 1) Ensure build exists (configure + build if missing)
if [[ ! -d "$BUILD_DIR" ]]; then
    echo "Configuring coverage build (docker-coverage preset)..."
    (cd "$PROJECT_ROOT" && cmake --preset docker-coverage)
fi

if [[ ! -x "$TEST_BIN" ]]; then
    echo "Building coverage target..."
    (cd "$PROJECT_ROOT" && cmake --build "$BUILD_DIR_REL" --parallel)
fi

if [[ ! -x "$TEST_BIN" ]]; then
    echo "ERROR: Test binary not found: $TEST_BIN"
    exit 1
fi

# Check for existing coverage data and optionally clean if requested
EXISTING_GCDA=$(find "$BUILD_DIR" -name '*.gcda' | wc -l)
if [[ "$EXISTING_GCDA" -gt 0 ]]; then
    echo "Found $EXISTING_GCDA existing .gcda files. Using existing coverage data."
    echo "To clean and regenerate, set CLEAN_COVERAGE=1"
fi

if [[ "${CLEAN_COVERAGE:-0}" == "1" ]]; then
    echo "Cleaning stale coverage data (.gcda) in $BUILD_DIR..."
    find "$BUILD_DIR" -type f -name '*.gcda' -delete 2>/dev/null || true
fi

# 2) Run tests to generate .gcda data (only if we don't have existing data or if cleaned)
if [[ "$EXISTING_GCDA" -eq 0 ]] || [[ "${CLEAN_COVERAGE:-0}" == "1" ]]; then
    echo "Running tests with coverage instrumentation..."
    export GCOV_PREFIX_STRIP=0
    export GCOV_PREFIX="$BUILD_DIR"
    if ! timeout 90 "$TEST_BIN" --gtest_brief=yes; then
        echo "ERROR: Tests failed (see output above). Proceeding to collect coverage anyway."
    fi
else
    echo "Skipping test execution - using existing coverage data"
fi

# Ensure gcda files are written to disk before gcovr
echo "Syncing coverage data to disk..."
sync
sleep 1

# Verify that coverage data was generated
GCDA_COUNT=$(find "$BUILD_DIR" -name '*.gcda' | wc -l)
echo "Coverage data files found: $GCDA_COUNT .gcda files"
if [[ "$GCDA_COUNT" -eq 0 ]]; then
    echo "WARNING: No coverage data files (.gcda) found. Tests may not have generated coverage."
fi

# 3) Generate coverage reports (prefer gcovr; fallback to basic gcov if needed)
echo "Generating coverage reports..."
if command -v gcovr >/dev/null 2>&1; then
    # Generate reports with corrected gcovr parameters
    (
        cd "$PROJECT_ROOT"
        gcovr --root src \
            --gcov-object-directory "$BUILD_DIR_REL" \
            --gcov-ignore-errors=no_working_dir_found \
            --exclude '.*_deps.*' \
            --exclude '.*/tests/.*' \
            --exclude '.*CMake.*' \
            --txt >"$TXT_LOG" 2>&1 || true

        gcovr --root src \
            --gcov-object-directory "$BUILD_DIR_REL" \
            --gcov-ignore-errors=no_working_dir_found \
            --exclude '.*_deps.*' \
            --exclude '.*/tests/.*' \
            --exclude '.*CMake.*' \
            --xml -o "$XML_OUT" >/dev/null 2>&1 || true

        gcovr --root src \
            --gcov-object-directory "$BUILD_DIR_REL" \
            --gcov-ignore-errors=no_working_dir_found \
            --exclude '.*_deps.*' \
            --exclude '.*/tests/.*' \
            --exclude '.*CMake.*' \
            --html --html-details -o "$HTML_DIR/index.html" >/dev/null 2>&1 || true
    )

    echo "Coverage text log: $TXT_LOG"
    echo "Coverage XML:      $XML_OUT"
    echo "Coverage HTML:     $HTML_DIR/index.html"

    # Parse coverage percent from text log
    COVERAGE_PERCENT=""
    if grep -E 'lines:' "$TXT_LOG" >/dev/null 2>&1; then
        COVERAGE_PERCENT=$(grep -E 'lines:' "$TXT_LOG" | tail -1 | sed -E 's/.*lines:\s*([0-9]+\.?[0-9]*)%.*/\1/')
    elif grep -E '^TOTAL' "$TXT_LOG" >/dev/null 2>&1; then
        COVERAGE_PERCENT=$(grep -E '^TOTAL' "$TXT_LOG" | awk '{for(i=1;i<=NF;i++){if($i ~ /%/){gsub("%","",$i); print $i; exit}}}')
    fi

        if [[ -n "${COVERAGE_PERCENT}" ]]; then
        echo ""
        echo "=== COVERAGE SUMMARY ==="
            echo "Total line coverage: ${COVERAGE_PERCENT}% (target ${COVERAGE_TARGET}%, enforce=${ENFORCE_COVERAGE})"
        # Integer compare using bash (drop decimals)
        pct_int=${COVERAGE_PERCENT%.*}
            if (( pct_int >= COVERAGE_TARGET )); then
            echo "✓ SUCCESS: Coverage target met"
            exit 0
        else
                echo "⚠ WARNING: Coverage (${COVERAGE_PERCENT}%) below target (${COVERAGE_TARGET}%)"
                if [[ "$ENFORCE_COVERAGE" == "true" ]]; then
                    exit 1
                else
                    exit 0
                fi
        fi
    else
        echo "⚠ WARNING: Could not parse coverage percent from gcovr output"
        exit 0
    fi
else
    echo "gcovr not found; attempting minimal gcov-based summary..."
    (
        cd "$BUILD_DIR"
        # Generate basic .gcov files for core sources
        find "$PROJECT_ROOT/src" -name '*.cpp' -print0 | xargs -0 -I{} gcov -o . {}
    ) || true
    echo "Basic gcov run complete (no percentage enforcement)."
    exit 0
fi
